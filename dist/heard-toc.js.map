{
  "version": 3,
  "sources": ["../src/toc/headings.ts", "../src/toc/builder.ts", "../src/toc/scroll-spy.ts", "../src/toc/index.ts"],
  "sourcesContent": ["/**\n * Heading discovery and processing across multiple containers\n */\n\nexport interface HeadingEntry {\n  el: HTMLElement;\n  level: number;\n  text: string;\n  id: string;\n  omitted: boolean;\n}\n\nconst DIRECTIVE_OMIT = /\\[heard-toc-omit\\]/gi;\nconst DIRECTIVE_LEVEL = /\\[heard-toc-h([2-6])\\]/gi;\n\n/**\n * Generate a URL-friendly slug from text\n */\nfunction slugify(text: string): string {\n  return text\n    .toLowerCase()\n    .trim()\n    .replace(/[^\\w\\s-]/g, '') // Remove special characters\n    .replace(/[\\s_-]+/g, '-') // Replace spaces and underscores with hyphens\n    .replace(/^-+|-+$/g, ''); // Remove leading/trailing hyphens\n}\n\n/**\n * Parse and strip directives from heading text\n */\nfunction parseDirectives(text: string): {\n  cleanText: string;\n  omitted: boolean;\n  overrideLevel?: number;\n} {\n  let cleanText = text;\n  let omitted = false;\n  let overrideLevel: number | undefined;\n\n  // Check for omit directive\n  if (DIRECTIVE_OMIT.test(text)) {\n    omitted = true;\n    cleanText = cleanText.replace(DIRECTIVE_OMIT, '').trim();\n  }\n\n  // Check for level override directive\n  const levelMatch = DIRECTIVE_LEVEL.exec(text);\n  if (levelMatch) {\n    overrideLevel = parseInt(levelMatch[1], 10);\n    cleanText = cleanText.replace(DIRECTIVE_LEVEL, '').trim();\n  }\n\n  return { cleanText, omitted, overrideLevel };\n}\n\n/**\n * Extract heading level from element tag name (h2 -> 2, h3 -> 3, etc.)\n */\nfunction getHeadingLevel(el: HTMLElement): number {\n  const tagName = el.tagName.toLowerCase();\n  const match = tagName.match(/^h([2-6])$/);\n  return match ? parseInt(match[1], 10) : 0;\n}\n\n/**\n * Discover all headings across multiple content containers\n */\nexport function discoverHeadings(): HeadingEntry[] {\n  const contentsElements = document.querySelectorAll<HTMLElement>(\n    '[heard-toc-element=\"contents\"]'\n  );\n\n  if (contentsElements.length === 0) {\n    console.warn('[Heard TOC] No elements with heard-toc-element=\"contents\" found');\n    return [];\n  }\n\n  const headings: HeadingEntry[] = [];\n  const idMap = new Map<string, number>(); // Track IDs for deduplication\n\n  // Process each contents element in DOM order\n  contentsElements.forEach((container) => {\n    const headingElements = container.querySelectorAll<HTMLElement>('h2, h3, h4, h5, h6');\n\n    headingElements.forEach((headingEl) => {\n      const level = getHeadingLevel(headingEl);\n      if (level === 0) return; // Skip invalid headings\n\n      // Skip headings inside AEO/key takeaways blocks\n      if (headingEl.closest('.aeo-keytakeaways')) return;\n\n      // Get text content and parse directives\n      const rawText = headingEl.textContent || '';\n      const { cleanText, omitted, overrideLevel } = parseDirectives(rawText);\n\n      if (!cleanText) return; // Skip empty headings\n\n      // Determine effective level (use override if present)\n      const effectiveLevel = overrideLevel || level;\n\n      // Generate unique ID\n      let baseId = slugify(cleanText);\n      if (!baseId) {\n        baseId = `heading-${headings.length + 1}`;\n      }\n\n      // Deduplicate IDs\n      let finalId = baseId;\n      if (idMap.has(finalId)) {\n        const count = idMap.get(finalId)! + 1;\n        idMap.set(finalId, count);\n        finalId = `${baseId}-${count}`;\n      } else {\n        idMap.set(finalId, 1);\n      }\n\n      // Set ID attribute on heading element\n      headingEl.id = finalId;\n\n      headings.push({\n        el: headingEl,\n        level: effectiveLevel,\n        text: cleanText,\n        id: finalId,\n        omitted,\n      });\n    });\n  });\n\n  return headings;\n}\n", "/**\n * TOC DOM generation using existing styled elements\n * \n * Expected Webflow DOM structure:\n * \n * <div heard-toc-element=\"table\" class=\"fs-toc_sidebar\">\n *   <h3>Table of Contents</h3>\n *   <div class=\"fs-toc_link-content\">\n *     <div class=\"fs-toc_link-wrapper is-h2\">\n *       <a class=\"fs-toc_link w-inline-block\">\n *         <div heard-toc-element=\"link\" class=\"fs-toc_link-h2\">Heading text</div>\n *       </a>\n *       <div class=\"fs-toc_link-wrapper is-h3\">\n *         <a class=\"fs-toc_link is-h3 w-inline-block\">Sub heading text</a>\n *       </div>\n *       <div fs-toc-element=\"ix-trigger\" class=\"fs-toc_h-trigger\"></div>\n *     </div>\n *   </div>\n * </div>\n */\n\nimport type { HeadingEntry } from './headings';\n\n/**\n * Captured template information from the original DOM\n */\ninterface TOCTemplate {\n  /** The container element where TOC link wrappers are placed (fs-toc_link-content) */\n  linkContent: HTMLElement;\n  /** The outer table element (fs-toc_sidebar) */\n  tableEl: HTMLElement;\n  /** Classes for the wrapper div (e.g. \"fs-toc_link-wrapper\") */\n  wrapperBaseClasses: string[];\n  /** Classes for the anchor element (e.g. \"fs-toc_link w-inline-block\") */\n  linkClasses: string[];\n  /** Classes for the text div inside the anchor (e.g. \"fs-toc_link-h2\") - may be null if text is directly in the <a> */\n  textDivBaseClass: string | null;\n}\n\n/**\n * Discover and capture template information from the existing Webflow DOM,\n * then clear the link-content container for fresh population.\n */\nfunction captureTemplate(): TOCTemplate | null {\n  // Find the table element\n  const tableEl = document.querySelector<HTMLElement>('[heard-toc-element=\"table\"]') ||\n                  document.querySelector<HTMLElement>('.fs-toc_sidebar');\n\n  if (!tableEl) {\n    console.warn('[Heard TOC] No TOC table element found. Add heard-toc-element=\"table\".');\n    return null;\n  }\n\n  // Find the link-content container (where wrappers go)\n  const linkContent = tableEl.querySelector<HTMLElement>('.fs-toc_link-content') ||\n                      tableEl.querySelector<HTMLElement>('[class*=\"toc_link-content\"]');\n\n  if (!linkContent) {\n    // If no nested link-content, the table itself might be the container\n    // Look for wrapper children directly\n    const firstWrapper = tableEl.querySelector<HTMLElement>('.fs-toc_link-wrapper') ||\n                         tableEl.querySelector<HTMLElement>('[class*=\"toc_link-wrapper\"]');\n    if (!firstWrapper) {\n      console.warn('[Heard TOC] No link-content container found inside TOC table.');\n      return null;\n    }\n    // Use tableEl as the container\n    return captureFromContainer(tableEl, tableEl, firstWrapper);\n  }\n\n  // Find the first wrapper to use as template\n  const firstWrapper = linkContent.querySelector<HTMLElement>(':scope > .fs-toc_link-wrapper') ||\n                       linkContent.querySelector<HTMLElement>('.fs-toc_link-wrapper');\n\n  if (!firstWrapper) {\n    console.warn('[Heard TOC] No fs-toc_link-wrapper found inside link-content.');\n    return null;\n  }\n\n  return captureFromContainer(tableEl, linkContent, firstWrapper);\n}\n\n/**\n * Extract template data from a wrapper element\n */\nfunction captureFromContainer(\n  tableEl: HTMLElement,\n  linkContent: HTMLElement,\n  firstWrapper: HTMLElement,\n): TOCTemplate | null {\n  // Capture wrapper base classes (without level-specific ones like is-h2, is-h3)\n  const wrapperBaseClasses = Array.from(firstWrapper.classList).filter(\n    cls => !cls.match(/^is-h[2-6]$/)\n  );\n\n  // Find the anchor inside the wrapper\n  const anchor = firstWrapper.querySelector<HTMLAnchorElement>(':scope > a.fs-toc_link') ||\n                 firstWrapper.querySelector<HTMLAnchorElement>(':scope > a') ||\n                 firstWrapper.querySelector<HTMLAnchorElement>('a.fs-toc_link') ||\n                 firstWrapper.querySelector<HTMLAnchorElement>('a');\n\n  if (!anchor) {\n    console.warn('[Heard TOC] No anchor element found inside wrapper template.');\n    return null;\n  }\n\n  // Capture link classes\n  const linkClasses = Array.from(anchor.classList).filter(\n    cls => !cls.match(/^is-h[2-6]$/)\n  );\n\n  // Check if there's a text div inside the anchor (like fs-toc_link-h2)\n  const textDiv = anchor.querySelector<HTMLElement>('[heard-toc-element=\"link\"]') ||\n                  anchor.querySelector<HTMLElement>('[class*=\"fs-toc_link-h\"]');\n\n  let textDivBaseClass: string | null = null;\n  if (textDiv) {\n    // Get the base class without the level number, e.g. \"fs-toc_link-h\" from \"fs-toc_link-h2\"\n    const cls = Array.from(textDiv.classList).find(c => c.match(/fs-toc_link-h\\d?/));\n    if (cls) {\n      // Strip the trailing digit to get base\n      textDivBaseClass = cls.replace(/\\d$/, '');\n    } else {\n      textDivBaseClass = textDiv.className.split(' ')[0] || null;\n    }\n  }\n\n  // Clear only existing TOC wrapper items, preserving any hard-coded\n  // non-wrapper elements (e.g. divider/trigger below the final link).\n  const existingWrappers = linkContent.querySelectorAll(':scope > .fs-toc_link-wrapper');\n  existingWrappers.forEach((wrapper) => wrapper.remove());\n\n  return {\n    linkContent,\n    tableEl,\n    wrapperBaseClasses,\n    linkClasses,\n    textDivBaseClass,\n  };\n}\n\n/**\n * Create a single TOC entry wrapper for a heading\n */\nfunction createWrapperForHeading(\n  heading: HeadingEntry,\n  template: TOCTemplate,\n): HTMLElement {\n  // Create wrapper div\n  const wrapper = document.createElement('div');\n  template.wrapperBaseClasses.forEach(cls => wrapper.classList.add(cls));\n  \n  // Add level class (is-h2, is-h3, etc.)\n  wrapper.classList.add(`is-h${heading.level}`);\n\n  // Create anchor\n  const anchor = document.createElement('a');\n  template.linkClasses.forEach(cls => anchor.classList.add(cls));\n  anchor.href = `#${heading.id}`;\n\n  // Add level-specific class to anchor for h3+ (e.g. \"is-h3\")\n  if (heading.level >= 3 && heading.level <= 6) {\n    anchor.classList.add(`is-h${heading.level}`);\n  }\n\n  // Create text element\n  if (template.textDivBaseClass) {\n    const textDiv = document.createElement('div');\n    textDiv.className = `${template.textDivBaseClass}${heading.level}`;\n    textDiv.textContent = heading.text;\n    anchor.appendChild(textDiv);\n  } else {\n    anchor.textContent = heading.text;\n  }\n\n  wrapper.appendChild(anchor);\n\n  return wrapper;\n}\n\n/**\n * Build TOC by creating fresh elements based on the captured template.\n * All entries are placed as flat siblings in the link-content container.\n * Level-specific styling (indentation, font size) is handled via CSS classes (is-h2, is-h3, etc.)\n */\nfunction populateTOC(\n  headings: HeadingEntry[],\n  template: TOCTemplate,\n): void {\n  const visibleHeadings = headings.filter(h => !h.omitted);\n\n  if (visibleHeadings.length === 0) {\n    return;\n  }\n\n  visibleHeadings.forEach((heading) => {\n    const wrapper = createWrapperForHeading(heading, template);\n    template.linkContent.appendChild(wrapper);\n  });\n}\n\n/**\n * Build and populate the TOC using existing DOM elements\n */\nexport function buildTOC(headings: HeadingEntry[]): boolean {\n  if (headings.length === 0) {\n    console.warn('[Heard TOC] No headings found to build TOC');\n    return false;\n  }\n\n  const template = captureTemplate();\n  if (!template) {\n    return false;\n  }\n\n  // Populate with heading data\n  populateTOC(headings, template);\n\n  const visibleCount = headings.filter(h => !h.omitted).length;\n  console.log(`[Heard TOC] Populated ${visibleCount} TOC item(s)`);\n\n  return true;\n}\n", "/**\n * IntersectionObserver-based active state tracking and smooth scrolling\n */\n\nimport type { HeadingEntry } from './headings';\n\ninterface ScrollSpyConfig {\n  offsetTop?: string;\n  offsetBottom?: string;\n  hideUrlHash: boolean;\n}\n\ninterface ScrollToHeadingOptions {\n  behavior?: ScrollBehavior;\n  updateHash?: boolean;\n}\n\n/**\n * Parse CSS value to pixels (approximate)\n */\nfunction parseCSSValue(value: string): number {\n  const num = parseFloat(value);\n  if (value.includes('rem')) {\n    return num * 16; // 1rem = 16px (approximate)\n  } else if (value.includes('em')) {\n    return num * 16; // Approximate\n  } else if (value.includes('px')) {\n    return num;\n  } else if (value.includes('vh')) {\n    return (num / 100) * window.innerHeight;\n  }\n  return num; // Default to pixels\n}\n\n/**\n * Detect the height of fixed/sticky elements at the top of the page (e.g. navbar).\n * Returns the pixel height to use as scroll offset.\n * \n * This is called lazily (not at init) so that Webflow/other JS frameworks have\n * time to apply position:fixed to nav elements.\n */\nfunction detectStickyNavHeight(): number {\n  // Check scroll-padding-top on html or body first\n  const htmlScrollPad = getComputedStyle(document.documentElement).scrollPaddingTop;\n  if (htmlScrollPad && htmlScrollPad !== 'auto') {\n    const parsed = parseCSSValue(htmlScrollPad);\n    if (parsed > 0) return parsed;\n  }\n  \n  const bodyScrollPad = getComputedStyle(document.body).scrollPaddingTop;\n  if (bodyScrollPad && bodyScrollPad !== 'auto') {\n    const parsed = parseCSSValue(bodyScrollPad);\n    if (parsed > 0) return parsed;\n  }\n\n  // Look for fixed/sticky elements at the top of the page.\n  // We check ALL elements but limit to top-level structural ones to avoid\n  // matching child elements inside navs. querySelectorAll with tag names\n  // and direct structural selectors.\n  let maxHeight = 0;\n\n  // Strategy 1: Check <nav> and <header> tags directly\n  const structuralEls = document.querySelectorAll<HTMLElement>('nav, header');\n  structuralEls.forEach((el) => {\n    const style = getComputedStyle(el);\n    if (style.position === 'fixed' || style.position === 'sticky') {\n      const rect = el.getBoundingClientRect();\n      if (rect.top < 10 && rect.height > 0) {\n        maxHeight = Math.max(maxHeight, rect.bottom);\n      }\n    }\n  });\n\n  // Strategy 2: If nothing found, check body's direct children for fixed/sticky\n  if (maxHeight === 0) {\n    Array.from(document.body.children).forEach((el) => {\n      if (el instanceof HTMLElement) {\n        const style = getComputedStyle(el);\n        if (style.position === 'fixed' || style.position === 'sticky') {\n          const rect = el.getBoundingClientRect();\n          if (rect.top < 10 && rect.height > 0) {\n            maxHeight = Math.max(maxHeight, rect.bottom);\n          }\n        }\n      }\n    });\n  }\n\n  // Strategy 3: Webflow nav wrappers are sometimes transformed/animated and may\n  // not report position:fixed in early lifecycle. Measure known top nav shells.\n  const topNavCandidates = document.querySelectorAll<HTMLElement>(\n    '.nav-w-banner, .nav-section, [data-wf--global-navigation--variant], nav[role=\"banner\"], header[role=\"banner\"]'\n  );\n  topNavCandidates.forEach((el) => {\n    const rect = el.getBoundingClientRect();\n    const intersectsTopViewport = rect.top <= 8 && rect.bottom > 0;\n    if (intersectsTopViewport && rect.height > 0) {\n      maxHeight = Math.max(maxHeight, rect.bottom);\n    }\n  });\n\n  return maxHeight;\n}\n\n/**\n * Highest auto-detected top offset seen so far.\n * Keeping the max avoids regressions when nav height changes during load.\n */\nlet _detectedOffsetTopPx = 0;\n\n/**\n * Get the effective top offset in pixels, resolving it lazily.\n * This defers sticky nav detection until first use so that Webflow's JS\n * has time to apply position:fixed to nav elements.\n */\nfunction getEffectiveOffsetTop(config: ScrollSpyConfig): number {\n  if (config.offsetTop) {\n    return parseCSSValue(config.offsetTop);\n  }\n\n  const navHeight = detectStickyNavHeight();\n  if (navHeight > 0) {\n    const detectedWithBreathingRoom = navHeight + 20; // 20px breathing room\n    if (detectedWithBreathingRoom > _detectedOffsetTopPx) {\n      _detectedOffsetTopPx = detectedWithBreathingRoom;\n      console.log(`[Heard TOC] Auto-detected sticky nav offset: ${_detectedOffsetTopPx}px`);\n    }\n  }\n\n  return _detectedOffsetTopPx;\n}\n\n/**\n * Get scroll spy configuration from DOM attributes\n * Supports both heard-toc- and fs-toc- prefixes for compatibility\n * Checks table container first, then all contents elements.\n * If no explicit offset is set, auto-detects sticky nav height.\n */\nfunction getConfig(): ScrollSpyConfig {\n  // First, try to get config from table container (most convenient)\n  const tableEl = document.querySelector<HTMLElement>('[heard-toc-element=\"table\"]') ||\n                   document.querySelector<HTMLElement>('[fs-toc-element=\"table\"]') ||\n                   document.querySelector<HTMLElement>('.fs-toc_link-content');\n  \n  let offsetTop: string | undefined;\n  let offsetBottom: string | undefined;\n  let hideUrlHash = false;\n\n  // Check table container first\n  if (tableEl) {\n    offsetTop = tableEl.getAttribute('fs-toc-offsettop') ||\n                tableEl.getAttribute('heard-toc-offsettop') ||\n                undefined;\n    offsetBottom = tableEl.getAttribute('fs-toc-offsetbottom') ||\n                   tableEl.getAttribute('heard-toc-offsetbottom') ||\n                   undefined;\n    hideUrlHash = tableEl.getAttribute('fs-toc-hideurlhash') === 'true' ||\n                  tableEl.getAttribute('heard-toc-hideurlhash') === 'true';\n  }\n\n  // If not found on table, check all contents elements\n  if (!offsetTop && !offsetBottom) {\n    const contentsElements = document.querySelectorAll<HTMLElement>(\n      '[heard-toc-element=\"contents\"], [fs-toc-element=\"contents\"]'\n    );\n\n    for (let i = 0; i < contentsElements.length; i++) {\n      const contentsEl = contentsElements[i];\n      // Check for both heard-toc- and fs-toc- prefixes (fs-toc takes precedence)\n      const elOffsetTop = contentsEl.getAttribute('fs-toc-offsettop') ||\n                          contentsEl.getAttribute('heard-toc-offsettop');\n      const elOffsetBottom = contentsEl.getAttribute('fs-toc-offsetbottom') ||\n                             contentsEl.getAttribute('heard-toc-offsetbottom');\n      const elHideUrlHash = contentsEl.getAttribute('fs-toc-hideurlhash') === 'true' ||\n                           contentsEl.getAttribute('heard-toc-hideurlhash') === 'true';\n\n      // Use first element that has offset attributes\n      if (elOffsetTop || elOffsetBottom) {\n        offsetTop = elOffsetTop || undefined;\n        offsetBottom = elOffsetBottom || undefined;\n        hideUrlHash = elHideUrlHash;\n        break; // Use first one found\n      }\n      \n      // If no offset but has hideUrlHash, still set it\n      if (elHideUrlHash) {\n        hideUrlHash = true;\n      }\n    }\n  }\n\n  return {\n    offsetTop,\n    offsetBottom,\n    hideUrlHash,\n  };\n}\n\n/**\n * Find the TOC link element corresponding to a heading ID\n */\nfunction findTOCLink(headingId: string): HTMLElement | null {\n  // Look for anchor with href matching the heading ID\n  const link = document.querySelector<HTMLAnchorElement>(`a[href=\"#${headingId}\"]`);\n  if (link) {\n    return link;\n  }\n\n  // Fallback: look for element with data-toc-link attribute\n  return document.querySelector<HTMLElement>(`[data-toc-link=\"${headingId}\"]`);\n}\n\n/**\n * Find the parent heading for a given heading (e.g., H3's parent H2)\n */\nfunction findParentHeading(\n  heading: HeadingEntry,\n  headings: HeadingEntry[]\n): HeadingEntry | null {\n  // Find the most recent heading with a lower level that comes before this one\n  let parent: HeadingEntry | null = null;\n  \n  for (let i = 0; i < headings.length; i++) {\n    if (headings[i].id === heading.id) {\n      break;\n    }\n    if (headings[i].level < heading.level && !headings[i].omitted) {\n      parent = headings[i];\n    }\n  }\n  \n  return parent;\n}\n\n/**\n * Check if a heading is in context (its parent is also visible/active)\n */\nfunction isHeadingInContext(\n  heading: HeadingEntry,\n  headings: HeadingEntry[]\n): boolean {\n  // H2s are always in context (top level)\n  if (heading.level === 2) {\n    return true;\n  }\n  \n  // For H3+, check if parent exists and is visible\n  const parent = findParentHeading(heading, headings);\n  if (!parent) {\n    return true; // No parent, so it's in context\n  }\n  \n  // Check if parent is above viewport (we've scrolled past it)\n  // This means the parent H2 is in context, so its children can be active\n  const parentRect = parent.el.getBoundingClientRect();\n  const viewportTop = window.scrollY;\n  const parentTop = window.scrollY + parentRect.top;\n  const parentBottom = window.scrollY + parentRect.bottom;\n  \n  // Parent is in context if:\n  // 1. It's above the viewport (we've scrolled past it), OR\n  // 2. It's currently visible in the viewport\n  return parentTop <= viewportTop + 300 || (parentTop >= viewportTop && parentBottom <= viewportTop + window.innerHeight);\n}\n\n/**\n * Update active state of TOC links with nested structure support\n */\nfunction updateActiveLink(activeHeadingId: string | null, headings: HeadingEntry[]) {\n  // Remove current class from all links\n  headings.forEach((heading) => {\n    const link = findTOCLink(heading.id);\n    if (link) {\n      link.classList.remove('w--current');\n    }\n  });\n\n  // Add current class to active link and ensure it's in context\n  if (activeHeadingId) {\n    const activeHeading = headings.find(h => h.id === activeHeadingId);\n    if (activeHeading && isHeadingInContext(activeHeading, headings)) {\n      const link = findTOCLink(activeHeadingId);\n      if (link) {\n        link.classList.add('w--current');\n        \n        // Trigger Webflow interaction if ix-trigger element exists\n        const trigger = link.closest('[heard-toc-element=\"ix-trigger\"]')?.parentElement\n          || link.querySelector('[heard-toc-element=\"ix-trigger\"]');\n        if (trigger) {\n          // Dispatch click event to trigger Webflow interaction\n          trigger.dispatchEvent(new MouseEvent('click', { bubbles: true }));\n        }\n      }\n    }\n  }\n}\n\n/**\n * Smooth scroll to heading with offset\n */\nfunction scrollToHeading(\n  headingId: string,\n  config: ScrollSpyConfig,\n  options: ScrollToHeadingOptions = {},\n): void {\n  const heading = document.getElementById(headingId);\n  if (!heading) return;\n\n  const behavior = options.behavior ?? 'smooth';\n  const shouldUpdateHash = options.updateHash ?? true;\n  const offsetTop = getEffectiveOffsetTop(config);\n  const headingRect = heading.getBoundingClientRect();\n  const targetTop = Math.max(0, window.scrollY + headingRect.top - offsetTop - 8);\n\n  window.scrollTo({\n    top: targetTop,\n    behavior,\n  });\n\n  // Update URL hash if not hidden\n  if (shouldUpdateHash && !config.hideUrlHash) {\n    // Use replaceState to avoid adding to history\n    const url = new URL(window.location.href);\n    url.hash = headingId;\n    window.history.replaceState(null, '', url.toString());\n  }\n}\n\n/**\n * Apply scroll margin to all heading targets so both deep links and JS\n * scrolling land below the sticky nav.\n */\nfunction applyHeadingScrollMargin(headings: HeadingEntry[], config: ScrollSpyConfig): void {\n  const offsetTop = getEffectiveOffsetTop(config);\n  const scrollMarginTop = `${Math.max(0, offsetTop + 8)}px`;\n\n  headings.forEach((heading) => {\n    heading.el.style.scrollMarginTop = scrollMarginTop;\n  });\n}\n\n/**\n * Ensure deep-linked URLs (page load with #hash) respect offset.\n * Browser native anchor jumps ignore JS offsets, so we re-apply position.\n */\nfunction setupInitialHashOffset(config: ScrollSpyConfig): void {\n  const applyHashOffset = () => {\n    const rawHash = window.location.hash;\n    if (!rawHash || rawHash.length < 2) return;\n\n    const headingId = decodeURIComponent(rawHash.slice(1));\n    if (!headingId) return;\n\n    const heading = document.getElementById(headingId);\n    if (!heading) return;\n\n    scrollToHeading(headingId, config, { behavior: 'auto', updateHash: false });\n  };\n\n  requestAnimationFrame(() => {\n    requestAnimationFrame(() => {\n      applyHashOffset();\n      window.setTimeout(applyHashOffset, 120);\n    });\n  });\n\n  window.addEventListener('hashchange', () => {\n    applyHashOffset();\n  });\n}\n\n/**\n * Handle TOC link clicks\n */\nfunction setupLinkClickHandlers(headings: HeadingEntry[], config: ScrollSpyConfig): void {\n  headings.forEach((heading) => {\n    const link = findTOCLink(heading.id);\n    if (!link) return;\n\n    link.addEventListener('click', (e) => {\n      // Only handle if it's an anchor with hash or data attribute\n      const isAnchor = link.tagName === 'A';\n      const href = isAnchor ? (link as HTMLAnchorElement).href : null;\n      \n      if (href && href.includes('#')) {\n        // Prevent native hash jump and third-party smooth-scroll handlers.\n        e.preventDefault();\n        e.stopPropagation();\n        if ('stopImmediatePropagation' in e) {\n          e.stopImmediatePropagation();\n        }\n      }\n\n      scrollToHeading(heading.id, config);\n    });\n  });\n}\n\n/**\n * Initialize scroll spy with IntersectionObserver\n */\nexport function initScrollSpy(headings: HeadingEntry[]): void {\n  if (headings.length === 0) return;\n\n  const config = getConfig();\n  \n  // Resolve offsets lazily \u2014 this defers nav detection until first scroll/click\n  // For IntersectionObserver rootMargin we need a value at setup time,\n  // so we resolve it now (after DOMContentLoaded, Webflow JS should have run).\n  // We use requestAnimationFrame to allow one more paint cycle.\n  const offsetBottom = config.offsetBottom ? parseCSSValue(config.offsetBottom) : 0;\n\n  // Setup click handlers immediately (they resolve offset lazily on click)\n  applyHeadingScrollMargin(headings, config);\n  setupLinkClickHandlers(headings, config);\n  setupInitialHashOffset(config);\n\n  const setupObserver = () => {\n    requestAnimationFrame(() => {\n      requestAnimationFrame(() => {\n        _setupScrollSpy(headings, config, offsetBottom);\n      });\n    });\n  };\n\n  if (document.readyState === 'complete') {\n    setupObserver();\n  } else {\n    window.addEventListener('load', setupObserver, { once: true });\n  }\n\n  // Keep margin in sync with responsive nav height changes\n  window.addEventListener('resize', () => {\n    applyHeadingScrollMargin(headings, config);\n  }, { passive: true });\n\n  window.addEventListener('load', () => {\n    applyHeadingScrollMargin(headings, config);\n  }, { once: true });\n}\n\nfunction _setupScrollSpy(\n  headings: HeadingEntry[],\n  config: ScrollSpyConfig,\n  offsetBottom: number,\n): void {\n  const getOffsetTop = (): number => getEffectiveOffsetTop(config);\n  const offsetTop = getOffsetTop();\n  \n  const rootMarginTop = offsetTop > 0 ? `-${offsetTop}px` : '0px';\n  const rootMarginBottom = offsetBottom > 0 ? `-${offsetBottom}px` : '0px';\n  const rootMargin = `${rootMarginTop} 0px ${rootMarginBottom} 0px`;\n\n  // Track which heading is currently active\n  let activeHeadingId: string | null = null;\n\n  // Create IntersectionObserver\n  const observer = new IntersectionObserver(\n    (entries: IntersectionObserverEntry[]) => {\n      // Find the entry with the highest intersection ratio that's intersecting\n      let bestEntry: IntersectionObserverEntry | null = null;\n      let bestRatio = 0;\n\n      for (const entry of entries) {\n        if (entry.isIntersecting && entry.intersectionRatio > bestRatio) {\n          bestRatio = entry.intersectionRatio;\n          bestEntry = entry;\n        }\n      }\n\n      // If we have a best entry, update active state\n      if (bestEntry !== null) {\n        const target = bestEntry.target as HTMLElement;\n        const headingId = target.id;\n        if (headingId && headingId !== activeHeadingId) {\n          activeHeadingId = headingId;\n          updateActiveLink(activeHeadingId, headings);\n        }\n      } else {\n        // Check if we should activate based on scroll position\n        // Find the heading closest to the top of the viewport that's in context\n        const viewportTop = window.scrollY + getOffsetTop();\n        let closestHeading: HeadingEntry | null = null;\n        let closestDistance = Infinity;\n\n        for (const heading of headings) {\n          if (heading.omitted) continue;\n          \n          // Check if heading is in context (parent is also visible)\n          if (!isHeadingInContext(heading, headings)) {\n            continue;\n          }\n          \n          const rect = heading.el.getBoundingClientRect();\n          const headingTop = window.scrollY + rect.top;\n          const distance = Math.abs(headingTop - viewportTop);\n\n          if (headingTop <= viewportTop + 100 && distance < closestDistance) {\n            closestDistance = distance;\n            closestHeading = heading;\n          }\n        }\n\n        if (closestHeading !== null && closestHeading.id !== activeHeadingId) {\n          activeHeadingId = closestHeading.id;\n          updateActiveLink(activeHeadingId, headings);\n        }\n      }\n    },\n    {\n      rootMargin,\n      threshold: [0, 0.1, 0.5, 1.0],\n    }\n  );\n\n  // Observe all headings\n  headings.forEach((heading) => {\n    observer.observe(heading.el);\n  });\n\n  // Initial active state check\n  const checkInitialActive = () => {\n    const viewportTop = window.scrollY + getOffsetTop();\n    let activeId: string | null = null;\n\n    for (const heading of headings) {\n      if (heading.omitted) continue;\n      \n      // Only consider headings that are in context\n      if (!isHeadingInContext(heading, headings)) {\n        continue;\n      }\n      \n      const rect = heading.el.getBoundingClientRect();\n      const headingTop = window.scrollY + rect.top;\n      \n      if (headingTop <= viewportTop + 100) {\n        activeId = heading.id;\n      } else {\n        break;\n      }\n    }\n\n    if (activeId) {\n      updateActiveLink(activeId, headings);\n    }\n  };\n\n  // Check on load and scroll\n  checkInitialActive();\n  window.addEventListener('scroll', checkInitialActive, { passive: true });\n}\n", "/**\n * Table of Contents - Main entry point\n * Generates a unified TOC from multiple rich text blocks\n */\n\nimport { discoverHeadings } from './headings';\nimport { buildTOC } from './builder';\nimport { initScrollSpy } from './scroll-spy';\n\n/**\n * Webflow utility classes like `overflow-clip` on TOC ancestors prevent\n * `position: sticky` from working. Relax vertical overflow so sticky sidebars\n * can stick while preserving horizontal overflow behavior.\n */\nfunction enableStickyAncestors(): void {\n  const tocTable = document.querySelector<HTMLElement>('[heard-toc-element=\"table\"]') ||\n    document.querySelector<HTMLElement>('.fs-toc_sidebar');\n\n  if (!tocTable) return;\n\n  let current = tocTable.parentElement;\n  while (current && current !== document.body) {\n    const computed = getComputedStyle(current);\n    const overflowY = computed.overflowY;\n    const hasOverflowClipClass = current.classList.contains('overflow-clip');\n    const blocksSticky = overflowY === 'hidden' || overflowY === 'clip';\n\n    if (hasOverflowClipClass || blocksSticky) {\n      current.style.overflowY = 'visible';\n    }\n\n    current = current.parentElement;\n  }\n}\n\n/**\n * Initialize the Table of Contents\n */\nfunction init(): void {\n  try {\n    // Discover headings across all content containers\n    const headings = discoverHeadings();\n\n    if (headings.length === 0) {\n      console.warn('[Heard TOC] No headings found. Make sure you have elements with heard-toc-element=\"contents\" containing h2-h6 headings.');\n      return;\n    }\n\n    // Build the TOC structure\n    const success = buildTOC(headings);\n\n    if (!success) {\n      console.warn('[Heard TOC] Failed to build TOC. Check your template structure.');\n      return;\n    }\n\n    // Ensure sticky TOC/CTA can function inside Webflow layout wrappers\n    enableStickyAncestors();\n\n    // Initialize scroll spy for active state tracking\n    initScrollSpy(headings);\n\n    console.log(`[Heard TOC] Initialized with ${headings.length} heading(s)`);\n  } catch (error) {\n    console.error('[Heard TOC] Error initializing:', error);\n  }\n}\n\n// Initialize when DOM is ready\nif (document.readyState === 'loading') {\n  document.addEventListener('DOMContentLoaded', init);\n} else {\n  // DOM is already ready\n  init();\n}\n"],
  "mappings": "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",
  "names": ["firstWrapper"]
}
